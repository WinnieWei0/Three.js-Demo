<!DOCTYPE html>
<html lang="en">

<head>
  <title></title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      font-family: Monospace;
      background-color: #000;
      color: #fff;
      margin: 0px;
      overflow: hidden;
    }

    #info {
      color: #fff;
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      z-index: 100;
      display: block;
    }

    #info a,
    .button {
      color: #f00;
      font-weight: bold;
      text-decoration: underline;
      cursor: pointer
    }
  </style>
</head>

<body>
  <div id="info">
  </div>

  <script src="/js/three.min.js"></script>

  <script src="/lib/TrackballControls.js"></script>
  <script src="/lib/VTKLoader.js"></script>
  <script src="/lib/Detector.js"></script>
  <script src="/lib/stats.min.js"></script>

  <!-- <script>
    if (!Detector.webgl) Detector.addGetWebGLMessage();

    var container, stats;

    var camera, controls, scene, renderer;

    var cross;

    init();
    animate();

    function init() {

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1e10);
      camera.position.z = 0.2;

      controls = new THREE.TrackballControls(camera);

      controls.rotateSpeed = 5.0;
      controls.zoomSpeed = 5;
      controls.panSpeed = 2;

      controls.noZoom = false;
      controls.noPan = false;

      controls.staticMoving = false;
      controls.dynamicDampingFactor = 0.3;

      scene = new THREE.Scene();

      scene.add(camera);

      // light

      var dirLight = new THREE.DirectionalLight(0xffffff);
      dirLight.position.set(200, 200, 1000).normalize();

      camera.add(dirLight);
      camera.add(dirLight.target);

      var material = new THREE.MeshLambertMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      });

      var loader = new THREE.VTKLoader();
      // loader.addEventListener('load', function (event) {
      //   var geometry = event.content;
      //   var mesh = new THREE.Mesh(geometry, material);
      //   mesh.position.setY(-0.09);
      //   scene.add(mesh);
      // });
      // loader.load("/lib/assets/bunny.vtk");
      loader.load("http://127.0.0.1:8888/",function (event) {
        var geometry = event.content;
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.setY(-0.09);
        scene.add(mesh);
      });

      // renderer

      renderer = new THREE.WebGLRenderer({
        antialias: false
      });
      renderer.setClearColor(0x000000, 1);
      renderer.setSize(window.innerWidth, window.innerHeight);

      container = document.createElement('div');
      document.body.appendChild(container);
      container.appendChild(renderer.domElement);

      stats = new Stats();
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.top = '0px';
      container.appendChild(stats.domElement);

      //

      window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

      controls.handleResize();

    }

    function animate() {

      requestAnimationFrame(animate);

      // controls.update();
      renderer.render(scene, camera);

      // stats.update();

    }
  </script> -->
  <script>
    if (!Detector.webgl) Detector.addGetWebGLMessage();
    var container,stats;
    var camera,controls,scene,renderer;
    var cross;

          init();
          animate();

    function init() {
      //创建透视投影相机
      camera=new THREE.PerspectiveCamera(60,window.innerWidth,window.innerHeight,0.01, 1e10);
      camera.position.z=0.2;

      controls=new THREE.TrackballControls(camera);

      controls.rotateSpeed=5.0;
      controls.zoomSpeed=5;
      controls.panSpeed=2;

      controls.noZoom=false;
      controls.noPan=false;

      controls.staticMoving=false;
      controls.dynamicDampingFactor=0.3;

      //创建场景
      scene=new THREE.Scene();
      scene.add(camera);

      //光照--创建一个方向光
      // var dirLight=new THREE.DirectionalLight(0xffff00);
      // //设置光源位置
      // dirLight.position.set(200,200,1000).normalize();

      // camera.add(dirLight);
      // camera.add(dirLight.target);

      //创建兰伯特材质
      var material=new THREE.MeshFaceMaterial({color:0xff00ff,side:THREE.DoubleSide});

      //加载模型
      var loader=new THREE.VTKLoader();
      // loader.addEventListener('load',function (event) {
      //   var geometry=event.content;
      //   var mesh=new THREE.Mesh(geometry,material);
      //   mesh.position.setY(-0.09);
      //   scene.add(mesh);
      //         });
      // loader.load("lib/assets/bunny.vtk");
        console.log(111111111)
      loader.load("lib/assets/bunny.vtk",function (geometry) {
        console.log(222222222222,geometry)
        // var geometry = geometry.content;
        // geometry.computeFaceNormals()
        // geometry.computeVertexNormals()
        // geometry.computeCentroids();
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        geometry.computeBoundingSphere();
        console.log(33333333333,geometry)
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.setY(-0.09);
        scene.add(mesh);
      });
      //创建渲染器-不开启抗锯齿
      renderer=new THREE.WebGLRenderer({antialias:false})
      renderer.setClearColor(0x00ffff,1);
      //设置渲染窗口大小
      renderer.setSize(window.innerWidth,window.innerHeight);

      //body中创建一个div，然后将渲染的内容放置在此div中
      container=document.createElement('div');
      document.body.appendChild(container);
      container.appendChild(renderer.domElement);

      //实时查看浏览器渲染性能
      stats=new Stats();
      stats.domElement.style.position='absolute';
      stats.domElement.style.top='0px';
      container.appendChild(stats.domElement);

      //监听浏览器窗口大小改变的监听
      window.addEventListener('resize',onWindowResize,false);
          }

          //浏览器窗口大小改变，需要更新投影矩阵的宽高比，重新设置渲染窗口大小
    function onWindowResize() {
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth,window.innerHeight);
      controls.handleResize();
          }

          //实时渲染
          function animate() {
      renderer.render(scene,camera);
      stats.update();
      controls.update();
      requestAnimationFrame(animate);
          }


  </script>
  <!-- <script>

    var renderer;

    function initRender() {

        renderer = new THREE.WebGLRenderer({antialias:true});

        renderer.setSize(window.innerWidth, window.innerHeight);

        //告诉渲染器需要阴影效果

        renderer.setClearColor(0xffffff);

        document.body.appendChild(renderer.domElement);

    }

 

    var camera;

    function initCamera() {

        camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);

        camera.position.set(0, 40, 50);

        camera.lookAt(new THREE.Vector3(0,0,0));

    }

 

    var scene;

    function initScene() {

        scene = new THREE.Scene();

    }

 

    //初始化dat.GUI简化试验流程

    var gui;

    function initGui() {

        //声明一个保存需求修改的相关数据的对象

        gui = {

        };

        var datGui = new dat.GUI();

        //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）

    }

 

    var light;

    function initLight() {

        scene.add(new THREE.AmbientLight(0x444444));

 

        light = new THREE.PointLight(0xffffff);

        light.position.set(0,50,50);

 

        //告诉平行光需要开启阴影投射

        light.castShadow = true;

 

        scene.add(light);

    }

 

    function initModel() {

 

        //辅助工具

        var helper = new THREE.AxesHelper(50);

        scene.add(helper);

 

        var loader = new THREE.VTKLoader();

        loader.load("/lib/assets/bunny.vtk", function (geometry) {

            //模型的法向量有问题，更新一下法向量

            geometry.computeFaceNormals();

            geometry.computeVertexNormals();

            //创建纹理

            var mat = new THREE.MeshLambertMaterial({color: 0xaaaaaa});

            //创建模型

            var group = new THREE.Mesh(geometry, mat);

            group.scale.set(10, 10, 10);

            scene.add(group);

        });

    }

 

    //初始化性能插件

    var stats;

    function initStats() {

        stats = new Stats();

        document.body.appendChild(stats.dom);

    }

 

    //用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放

    var controls;

    function initControls() {

 

        controls = new THREE.OrbitControls( camera, renderer.domElement );

 

        // 如果使用animate方法时，将此函数删除

        //controls.addEventListener( 'change', render );

        // 使动画循环使用时阻尼或自转 意思是否有惯性

        controls.enableDamping = true;

        //动态阻尼系数 就是鼠标拖拽旋转灵敏度

        //controls.dampingFactor = 0.25;

        //是否可以缩放

        controls.enableZoom = true;

        //是否自动旋转

        controls.autoRotate = true;

        controls.autoRotateSpeed = 0.5;

        //设置相机距离原点的最远距离

        controls.minDistance  = 1;

        //设置相机距离原点的最远距离

        controls.maxDistance  = 200;

        //是否开启右键拖拽

        controls.enablePan = true;

    }

 

    function render() {

 

        renderer.render( scene, camera );

    }

 

    //窗口变动触发的函数

    function onWindowResize() {

 

        camera.aspect = window.innerWidth / window.innerHeight;

        camera.updateProjectionMatrix();

        render();

        renderer.setSize( window.innerWidth, window.innerHeight );

 

    }

 

    function animate() {

        //更新控制器

        render();

 

        //更新性能插件

        stats.update();

 

        controls.update();

 

        requestAnimationFrame(animate);

    }

 

    function draw() {

        initGui();

        initRender();

        initScene();

        initCamera();

        initLight();

        initModel();

        initControls();

        initStats();

 

        animate();

        window.onresize = onWindowResize;

    }

</script> -->

</body>

</html>